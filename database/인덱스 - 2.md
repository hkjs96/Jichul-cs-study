
####  개인 블로그에 포스팅한 내용의 요약본입니다. 자세한 내용은 [인덱스 - 2](https://dncjf64.tistory.com/389) 글에서 확인해주세요.

## 기본적인 B-Tree 구조
![Untitled](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FBLi5L%2FbtrdInhxyVP%2Febff3uYkmyoEty5lULR8kK%2Fimg.png)
- 탐색 성능을 높이기 위해 균형 있게 높이를 유지하는 *Balanced* Tree의 일종
- B-TREE의 조건
  1. node의 key의 수가 k개라면, 자식 node의 수는 k+1개이다.
  2. node의 key는 반드시 정렬된 상태여야 한다.
  3. 자식 node들의 key는 현재 node의 key를 기준으로 크기 순으로 나뉘게 된다.
  4. root node는 항상 2개 이상의 자식 node를 갖는다. (root node가 leaf node인 경우 제외)
  5. 모든 leaf node들은 같은 level에 있어야 한다.
- node의 자식 수 중 최댓값을 K라고 하면, 해당 B-TREE를 K차 B-TREE라 지칭
- 살구색 부분은 각 노드의 key이며, 주황색 부분은 자식 포인터를 가리키는 포인터
- 최상위에 있는 노드를 루트 노드, 가장 하위에 있는 노드를 리프 노드, 나머지 노드를 브랜치 노드
- key들은 노드 안에서 항상 정렬된 값을 가지며, 이진 검색 트리처럼 각 key들의 왼쪽 자식들은 항상 key보다 작은 값을, 
오른쪽은 큰 값을 갖는다. 중요한 점은 가운데 자식 노드는 부모 노드 key의 사이 값을 갖음
- 노드가 균형 있게 구성되어 있어서, 최악의 경우이더라도 일관된 탐색 시간(O(logN))을 갖음

## B+Tree
![Untitled](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbAARBC%2FbtrdDydoUp7%2F9h4KOXBRyDNKpKDAe2ugq0%2Fimg.png)
- B-TREE는 범위 검색시 트리의 모든 노드를 방문해야하는 단점이 있음
- B+TREE는 Leaf 노드들간에 LinkedList 형태로 연결되어 있음, 장점은 데이터 범위 검색시 한번 리프노드에서 특정
노드를 찾으면 이후 브랜치 노드의 개입 없이 데이터 검색 가능
- B-TREE는 루트노드, 브랜치노드에도 key값이 있지만, B+TREE는 리프노드에만 key값이 있음
- B+TREE를 사용하는 이유는 인덱스 컬럼은 부등호를 이용한 순차 검색 연산이 자주 발생
- 따라서 B+Tree의 Linked list를 이용하면 순차 검색을 효율적으로 할 수 있음
- B+TREE의 삽입과 삭제는 항상 Leaf 노드에서만 발생

## Mysql의 InnoDB에서 사용하는 B+Tree 구조

![Untitled](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbsCQie%2Fbtrhqf01cjz%2FXKfpi9Aa9fMCZkqw4cE22K%2Fimg.jpg)
- 루트 노드와 브랜치 노드는 자식 노드의 주소를 가리키지만, 리프 노드는 실제 데이터 레코드를 찾아가기 위한 주소 값을 가리킴
- 인덱스와 실제 데이터가 저장된 데이터는 따로 관리
- 인덱스 레코드를 key라고 생각하면 되고, 각각 정렬이 되어 있음
- 대부분 RDBMS의 데이터 파일은 특정 기준으로 정렬이 되어 있지 않음
  - InnoDB 테이블에서 레코드는 PK 기준으로 정렬되어 저장

## InnoDB의 인덱스 구조

### 개념

![Untitled](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FVqljj%2FbtrhhRTSCRj%2FuCyVbUqBkhl1SqLf5xiZS1%2Fimg.jpg)
- MySQL에서 가장 많이 쓰이는 InnoDB 스토리지 엔진에서 기본으로 하는 인덱스 구조
- InnoDB 테이블의 인덱스 리프 노드를 보면 레코드 주소 대신 PK가 있는데, 이 PK가 ROWID의 역할을 수행
- InnoDB 테이블은 PK를 주소처럼 사용하므로 논리적인 주소를 갖음
- InnoDB 테이블은 인덱스를 통해 인덱스를 읽을 때 데이터 파일을 바로 찾아가지 못하고, 인덱스에 저장되어 있는 PK 값을 이용해 
PK 인덱스(PK 컬럼이 인덱스로 설정된 인덱스)을 한 번 더 검색한 후 PK 인덱스의 리프 페이지에 저장되어 있는 레코드를 읽음
- 즉, InnoDB 스토리지 엔진에서는 모든 세컨더리 인덱스 검색에서 데이터 레코드를 읽기 위해 PK 인덱스 검색을 한번 더 수행
  - 이 구조로 인해 InnoDB 스토리지 엔진의 성능이 무조건 떨어질 것 같지만, 장단점이 있음
  - 모든 세컨더리 인덱스가 프라이머리 키를 가지고 있기 때문에 인덱스만으로 처리될 수 있는 경우가 많음(커버링 인덱스) 

## B-Tree 인덱스 사용에 영향을 미치는 요소

### 선택도(기수성)
- 인덱스 키 값 가운데 유니크한 값의 수를 의미한다.
- 전체 인덱스 키 값이 100개고, 유니크한 값의 수가 10개라면 기수성은 10이다.
- 인덱스는 선택도가 높을 수록 검색 대상이 줄어들기 때문에 그만큼 빠르게 처리된다.
- 예제
```
-- tb_test 테이블에는 1만 건의 레코드가 있다.
-- 국가와 도시가 중복되어 저장되지 않는다고 가정.
SELECT * FROM tb_test WHERE country = 'KOREA' AND city = 'SEOUL';
```
- country 컬럼의 유니크 값이 10개
  - 전체 레코드 건수를 유니크한 값의 개수로 나눠보면 하나의 키 값으로 검색했을 때 대략 몇 건의 레코드가 일치할지 예측 가능 
  즉, 이 케이스의 tb_city 테이블에서는 country = 'KOREA' 라는 조건으로 인덱스를 검색하면 1000건 (10,000 / 10)이 일치한다고 예상 가능,
  그런데 실제 인덱스를 통해 검색된 1000건 가운데 city = 'SEOUL' 인 레코드는 1건이므로 999건은 불필요하게 읽은 것

- country 컬럼의 유니크 값이 1000개
  - 위와 마찬가지로 예측 값은 10건 (10,000 / 1,000)이므로 실제 인덱스를 통해 검색된 10건 가운데 불필요한 레코드는 9건만 존재,
  즉 유니크 값이 높을 수록 불필요하게 검색되는 레코드의 양이 감소하므로 성능이 향상된다.

**읽어야 하는 레코드의 건수**
  - 일반적인 DBMS의 옵티마이저에서는 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드 1건을 읽는 것보다 4 ~ 5배정도 비용이 드는 작업이라고
예측
  - 즉 인덱스를 통해 읽어야 할 레코드의 건수가 전체 테이블 레코드의 20 ~ 25%를 넘어서면 인덱스를 사용하지 않고 일반 테이블 검색하는 것이 좋음

## B-Tree 인덱스 키 추가 및 삭제

**인덱스 키 추가**
- B-Tree 상의 적절한 위치에 key 값을 저장
- 저장될 위치가 결정되면 레코드의 키 값과 대상 레코드의 주소 정보를 리프 노드에 저장
- 리프 노드가 꽉 찼다면 리프 노드를 분리
  - 이 과정 때문에 새로운 키를 추가하는 작업이 일반 트리에 비해 비용이 많이 듬
    - 다만 일반 트리는 데이터가 한 쪽에 쏠려서 극단적으로 List와 같아질 수 있다는 단점 존재
- 평균적으로 일반 테이블에 레코드를 추가하는 작업 비용을 1이라고 하면, 해당 테이블의 인덱스에 키를 추가하는 작업 비용은 
1.5 정도 듬

**인덱스 키 삭제**
- 해당 키 값이 저장된 리프 노드를 찾아서 삭제 마크만 취함.

**인덱스 키 변경**
- 인덱스의 키 값은 그 값에 따라 저장될 리프 노드의 위치가 결정되므로 키 값이 변경되는 경우에 단순히 키 값만 변경하는 것은
불가능
- 기존 키 값에 삭제 마크를 취하고, 새로운 키를 노드에 추가 (삭제 + 추가)

## B-Tree 인덱스를 통한 데이터 읽기

### 인덱스 레인지 스캔
- 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식
- 검색하려는 값의 수나 검색 결과 레코드 건수와 관계 없이 레인지 스캔 
- 루트 노드에서부터 비교를 시작해 브랜치 노드를 거치고 최종적으로 리프 노드까지 찾아 들어감

**검색하려는 값이 1개**
![Untitled](https://camo.githubusercontent.com/a57b91cdfec9b5550c7c1f2e71500a317039165f7a3e22e0e7c1b679ee456591/68747470733a2f2f7777772e6e6f74696f6e2e736f2f696d6167652f687474707325334125324625324673332d75732d776573742d322e616d617a6f6e6177732e636f6d2532467365637572652e6e6f74696f6e2d7374617469632e636f6d25324666346662653238372d613631392d343264642d393038372d643966646136303333376434253246556e7469746c65642e706e673f7461626c653d626c6f636b2669643d30636539656434312d613137322d343961342d383962342d38626361306131636136336326737061636549643d62343533626438352d636231352d343462352d626632652d3538306165646138303734652677696474683d32303030267573657249643d38303335326331322d363561342d343536322d396133362d3231373965643064666666622663616368653d7632)

- ID가 3인 레코드를 찾는다고 가정할 때, 루트 노드로 접근하여 인덱스 레코드를 확인
- key값을 확인해 보니, 0부터 5까지는 페이지 2에 저장되어 있는 것을 알 수 있음
- 브랜치 노드로 내려가서 페이지 2로 접근
- 페이지 2에서 3부터 5까지는 페이지 5에 저장되어 있는 것을 확인
- 리프 노드로 내려가서 페이지 5로 접근
- 리프 노드에는 디스크에 저장되어 있는 물리적인 주소가 있음
- 리프 노드에서 ID가 3인 레코드를 찾고, 레코드 주소인 x9를 활용하여 디스크에 있는 데이터를 읽어 들임

**범위 검색**
```
SELECT * FROM employees WHERE first_name BETWEEN 'Ebbe' AND 'Gad';
```
![Untitled](https://camo.githubusercontent.com/04753896b540c334e6210ce2b39b3da85dbedbf38c0c8bce7d8044881f833b56/68747470733a2f2f7777772e6e6f74696f6e2e736f2f696d6167652f687474707325334125324625324673332d75732d776573742d322e616d617a6f6e6177732e636f6d2532467365637572652e6e6f74696f6e2d7374617469632e636f6d25324637306366363739332d353331642d343630632d386635302d613731633934663166623036253246556e7469746c65642e706e673f7461626c653d626c6f636b2669643d30663432653165322d653963362d346436642d393138382d36393165343837356335353726737061636549643d62343533626438352d636231352d343462352d626632652d3538306165646138303734652677696474683d32303030267573657249643d38303335326331322d363561342d343536322d396133362d3231373965643064666666622663616368653d7632)
- B-tree 인덱스에서 루트 노드와 브랜치 노드를 이용해 스캔 시작 위치를 검색하고, 그 지점부터 필요한 방향으로 인덱스를 읽어 나감
- 인덱스는 자체 정렬 특성이 있음
- 리프 노드에서 저장된 레코드 주소로 데이터 파일의 레코드를 읽어 오는데, 레코드 한 건 한 건 단위로 랜덤 I/O가 발생
  - 그래서 인덱스를 통해 읽어야 할 데이터가 20~25%를 넘으면 순차 I/O를 사용한 테이블 풀 스캔이 낫다고 하는 것

**인덱스 풀 스캔**
- 인덱스의 처음부터 끝까지 모두 읽는 방식
- 쿼리의 조건절에 사용된 컬럼이 첫 번째 컬럼이 아닌 경우 사용
  - ex) 인덱스는 (A, B, C) 컬럼의 순서로 만들어져 있지만, 쿼리의 조건절은 B 컬럼이나 C 컬럼으로 검색
    ![Untitled](https://camo.githubusercontent.com/f58089760ac8439d2fdac5fa86c4399e9b6bdb1d7a5e1716fec0226f98bb7477/68747470733a2f2f7777772e6e6f74696f6e2e736f2f696d6167652f687474707325334125324625324673332d75732d776573742d322e616d617a6f6e6177732e636f6d2532467365637572652e6e6f74696f6e2d7374617469632e636f6d25324636623737373435332d643764632d343933322d386435332d646461323735653335386532253246556e7469746c65642e706e673f7461626c653d626c6f636b2669643d63376338303735352d323463642d346561662d626233362d35383739633833306130373926737061636549643d62343533626438352d636231352d343462352d626632652d3538306165646138303734652677696474683d32303030267573657249643d38303335326331322d363561342d343536322d396133362d3231373965643064666666622663616368653d7632)
- 루트 노드의 첫 번째 인덱스 레코드와 이어진 브랜치 노드를 거쳐 리프 노드로 이동
- 해당 리프 노드의 첫 번째 페이지의 인덱스 레코드 방향부터 아래로 탐색
- 인덱스의 전체 크기는 테이블의 전체 크기보다 훨씬 작은 경우가 많으므로 풀 테이블 스캔보다는 적은 I/O로 쿼리를 처리 가능

**루스 인덱스 스캔**
- 루스 인덱스 스캔이란 말 그대로 느슨하게 또는 듬성듬성하게 인덱스를 읽는 것을 의미
- 인덱스 레인지 스캔과 비슷하게 동작하지만 중간마다 필요하지 않은 키 값은 무시
- 일반적으로 group by 또는 max 등의 함수에 대해 최적화할 때 사용
```
select dept_no, MIN(emp_no)
from dept_emp
where dept_no between 'doo2' and 'd004'
group by dept_no;
```
dept_emp 테이블은 dept_no와 emp_no 2개의 컬럼으로 인덱스를 구성하고 있다고 가정하며, 이 인덱스는 (dept_no, emp_no)를 기준으로 정렬이 되어 있음 
즉 특정 dept_no 그룹 별로 처음에 있는 emp_no만 읽으면 된다. 즉, 인덱스에서 where 조건을 만족하는 범위 전체를 다 스캔할 필요가 없다는 것을
옵티마이저는 알고 있으므로 중간 중간 조건에 맞지 않으면 건너 뜀
    ![Untitled](https://camo.githubusercontent.com/cdb6aa94fef2ee7d25453b235c7fdc8b1f9f7292878489af5af964fd22c23ed6/68747470733a2f2f7777772e6e6f74696f6e2e736f2f696d6167652f687474707325334125324625324673332d75732d776573742d322e616d617a6f6e6177732e636f6d2532467365637572652e6e6f74696f6e2d7374617469632e636f6d25324637323337383961382d333464652d343239332d613062332d386634636564636563363635253246556e7469746c65642e706e673f7461626c653d626c6f636b2669643d33336536306633372d313266662d346630302d393036382d63623833326136623337353626737061636549643d62343533626438352d636231352d343462352d626632652d3538306165646138303734652677696474683d32303030267573657249643d38303335326331322d363561342d343536322d396133362d3231373965643064666666622663616368653d7632)


### 정렬 방향
- 인덱스 생성 시 MySQL 5.7 이하 버전에선 칼럼마다 정렬 방향을 지정해서 생성 할 수 없었음
- MySQL 8.0 부터는 아래와 같이 역순으로 정렬되는 인덱스(Descending index)도 생성할 수 있게 됨
```
CREATE TABLE tb_wow (
  uid BIGINT PRIMARY KEY,
  age SMALLINT,
  score SMALLINT,
  INDEX ix_score_age (score DESC, age ASC)
);

SELECT * FROM tb_wow ORDER BY score ASC,  age DESC;
SELECT * FROM tb_wow ORDER BY score DESC, age ASC ;
```

## 다중 컬럼 인덱스
- 두 개 이상의 컬럼으로 구성된 인덱스를 다중 컬럼 인덱스
- 멀티 컬럼 인덱스, 복합 컬럼 인덱스, Concatenated Index라고도 부름
    ![Untitled](https://camo.githubusercontent.com/8b890a3cccd26850d2fe7bbe5ac070e3ae3f75002ec337af8892fd4638f2c233/68747470733a2f2f7777772e6e6f74696f6e2e736f2f696d6167652f687474707325334125324625324673332d75732d776573742d322e616d617a6f6e6177732e636f6d2532467365637572652e6e6f74696f6e2d7374617469632e636f6d25324633373833396638662d373766382d346539662d613564662d663537376361363130316533253246556e7469746c65642e706e673f7461626c653d626c6f636b2669643d38326638343562632d643438632d346535362d383862312d66353237646134666339383626737061636549643d62343533626438352d636231352d343462352d626632652d3538306165646138303734652677696474683d32303030267573657249643d38303335326331322d363561342d343536322d396133362d3231373965643064666666622663616368653d7632)

### 주의 사항
- 다중 컬럼 인덱스에서 중요한 것은 인덱스의 두 번째 컬럼은 첫 번째 컬럼에 의존해서 정렬되어 있다는 것 
- 즉, 두 번째 컬럼은 첫 번째 컬럼이 똑같은 레코드에서만 의미가 있음
- 따라서 다중 컬럼 인덱스에서는 컬럼의 위치(순서)가 상당히 중요하며 신중하게 결정
  - 조건과 같이 개수가 적은 데이터를 조회하는 컬럼을 다중 컬럼 인덱스 앞 쪽에 설정하고, 범위 검색과 같이 개수가 많은 데이터를 조회하는 컬럼을 다중 컬럼 인덱스 뒤쪽에 설정
- 단일 컬럼 인덱스보다 더 비효율적으로 Insert/Update/Delete를 수행하므로 가급적 업데이트가 안 되는 값을 선정해서 사용하는 것이 좋음

### 언제 사용할까?
- 데이터를 조회할 때 단일 인덱스를 여러 개를 사용해야 하는 경우가 많다면 다중 컬럼 인덱스를 고려
- A, B 컬럼을 바탕으로 데이터 탐색을 자주 한다고 가정
  - A, B 각각 인덱스 설정
    - A 컬럼과 B 컬럼을 보고 둘 중에 어떤 컬럼의 수가 빠르게 검색되는지 판단하고 더 빠른 쪽을 먼저 검색하고 그 다음 컬럼을 검색
  - (A, B) 한꺼번에 인덱스 설정
    - 인덱스 안에 A, B 정보가 있으므로 바로 검색이 가능하므로 위 방식보다 더 빠름
    - 다만 where 조건문에 B만 사용하면 인덱스를 타지 않는다. B는 A에 의존적으로 정렬이 되기 때문. (반대로 where 조건문에 A만 사용하는 것은 괜찮다.)
    
## 인덱스 실습
![Untitled](https://user-images.githubusercontent.com/52563841/150637449-a4259ce1-7669-4a1a-9160-cbf0a95935e8.png) 
- 30만건이 있는 employess 테이블
- 3개의 인덱스가 있음

```
select gender, birth_date from employees where
gender = 'M' and
birth_date >= '1965-02-01';
```
- 실험 쿼리

![Untitled](https://user-images.githubusercontent.com/52563841/150637495-b90a0fe7-c12b-4982-be4a-3e8f220069cf.png)
- ix_first_name 인덱스가 존재한 결과

![Untitled](https://user-images.githubusercontent.com/52563841/150637522-fb74af5c-547f-4437-9a40-46def75cca25.png)
- ix_first_name 인덱스를 지운 결과






