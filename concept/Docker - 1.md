## Docker 개념 

![Untitled](https://hudi.blog/static/ae7abadcb58ac11ac766516ee6cce476/a22ce/real-container.jpg)
- 도커는 컨테이너 기반의 오픈소스 가상화 플랫폼이다. 고(Go) 언어로 개발되었다.
- 선박 운영에 있어서 사용되는 컨테이너는 국제적으로 표준화, 규격화되어있어서, 운송장비, 제도, 프로세스 등이 
국제 표준에 맞게 설계되었다. 
- 도커의 컨테이너도 마찬가지로, 도커는 프로그램의 배포 및 관리 하는데 필요한 실행환경, 라이브러리, 시스템 도구 등 
응용프로그램을 실행하는데 필요한 모든 것을 컨테이너라는 표준화된 단위로 추상화하고 동일한 인터페이스를 제공한다.
- 만들어진 컨테이너는 컴퓨터 환경에 구애받지 않고 서비스가 실행될 수 있도록 도와준다.
- 컴퓨터에서 응용프로그램을 관리하는 것과 같은 방법으로 인프라를 관리할 수 있으며, 코드를 신속하게 개발하고
테스트 할 수 있어 실제 운영환경과 개발환경의 차이를 크게 줄일 수 있다.

## VM (Virtual Machine) vs 컨테이너 

### VM (Virtual Machine)
![Untitled](https://user-images.githubusercontent.com/52563841/153249640-9d7b08ad-5b9c-4c1a-a0b0-d8e5187ac0a2.png)
- 가상화 기술인 하이퍼 바이저 기반의 VM 구조를 나타내는 그림이다.
- 하이퍼 바이저란 호스트 OS에서 다수의 OS를 운영할 수 있게 해주는 소프트웨어이다.
- Virtual box 혹은 Vmware를 통해 Guest OS를 생성할 수 있다.
- 하이퍼바이저에 의해 구동되는 VM(Virtual Machine)은 독립된 가상 하드웨어 자원을 할당 받으며, 한쪽의 
VM에 오류가 발생해도 다른 VM으로 퍼지지 않게끔 서로 충돌이 나지 않는다.
- 호스트 OS의 일정량의 하드웨어 자원을 제공받아 Guest OS를 생성하기 때문에 오버헤드가 크다.
- 윈도우 호스트 OS에서 리눅스 환경에 테스트할 어플리케이션을 띄운다고 한다면 아래와 같은 과정을 거쳐야햐기
때문에 복잡하고 무겁다.
  1. Virtual box 혹은 Vmware를 통해 VM을 띄우고 자원을 할당 받는다.
  2. 게스트 OS를 부팅한다
  3. 어플리케이션을 실행한다.

```
💡 가상화 등장배경
하드웨어의 성능향상이 비약적으로 발전함에 따라 컴퓨터의 성능을 더욱 효율적으로 사용하기 위해 등장하였다.
옛날에는 한대의 서버를 하나의 용도로만 사용했기 때문에 막대한 비용과 시간이 소모되었다. 
또한 CPU 사용률이 10%대 밖에 되지 않는 서버의 남는 리소스를 충분히 활용해야 했다.
추가적인 문제점으로 하나의 OS에만 다양한 서비스를 운영중이면 안정성에 문제가 생길 여지가 있다.
해결책으로 가상화를 사용하여 한대의 서버에 다양한 OS를 설치하여 리소스를 최대한 활용하였고, 다양한 OS가 
격리된 공간에서 독립적으로 구성되어 있기 때문에 안정성이 높다는 장점이 있다.
```

### 컨테이너 방식
![Untitled](https://user-images.githubusercontent.com/52563841/153256366-7ba63795-0861-4983-8bfd-116b9ec45907.png) 
- 하이퍼바이저와 Guest OS 없이, 프로세스를 격리하는 방식으로 도커 엔진 위에서 동작한다.
- OS 레벨의 가상화라고 불리며, 위의 방식은 HW 레벨의 가상화이다.
- Host OS의 모든 기능과 리소스를 컨테이너간 공유하기 때문에 VM 구조보다 오버헤드가 적다.
- 같은 호스트의 다른 컨테이너와 동일한 커널을 공유한다.
  - 예를 들어 도커와 함께 몽고DB 컨테이너를 시작하면 호스트의 일반 쉘에 ps -ef | grep mongo를 실행하면
  프로세스가 표시된다.
- 하나의 컨테이너를 하나의 프로세스 개념으로 볼 수 있다.
- 운영체제를 별도로 가상화하지 않고 이미지 파일 개념을 사용하기 때문에 매우 가볍다.

### 도커 컨테이너 격리
![Untitled](https://user-images.githubusercontent.com/52563841/153328420-89535ee0-6194-4bdb-9617-dda4e60d82fb.png)
- 컨테이너는 격리되어 있는 구조이고 하드디스크 포함되므로, 카카오톡 혹은 노션이 필요한 만큼의 CPU,메모리를 
부여한다 
- Docker Engine은 리눅스 커널 기반이다. 따라서 리눅스 커널의 기능을 사용할 수 있다.
- 그 중 *C Group*, *namespace* 기능을  사용하여 컨테이너를 격리한다.
- C Group
  - CPU, 메모리, 등 프로세스 그룹의 시스템 리소스 사용량을 관리
  - 해당 기능 없이는 각각의 컨테이너에서 별도의 자원을 사용할 수 없다.
- namespace
  - 하나의 시스템에서 프로세스를 격리시킬 수 있는 가상화 기술
  - 별개의 독립된 공간을 사용하는 것처럼 격리된 환경을 제공하는 경량 프로세스 가상화 기술

## Docker 이미지와 컨테이너
### 이미지
![Untitled](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/689ad05d-4b44-4402-9400-6b11d4c1c31e/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20220209%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20220209T164415Z&X-Amz-Expires=86400&X-Amz-Signature=6227825659d80c67bf310bae98c8f57fff380c9103ec6e5b99c2a0b6cb056955&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22&x-id=GetObject)
- 도커 이미지는 컨테이너 실행에 필요한 파일과 설정값 등을 가지고 있으며 해당 이미지를 이용해서 컨테이너를
생성하며, 컨테이너를 이용해 프로그램을 실행한다.

### 특징
- 읽기전용 템플릿으로 볼 수 있다.
- 컨테이너를 실행하기 위한 모든 정보를 가지고 있기 때문에, 이것저것 설치할 필요성이 사라진다. 
- 하나의 이미지로 여러개의 컨테이너를 생성할 수 있다.
- scale-out 작업시 만들어 놓은 이미지를 다운받고 컨테이너를 생성하면 간편하게 작업을 할 수 있다.
- Dockerfile을 통해 나만의 이미지를 만들고 필요한 단계를 정의하여 만들 수 있다. 

### 레이어 저장방식
![Untitled](https://camo.githubusercontent.com/cec0d7d3aab72ab1170a5d0a959fb0e0c0314370b29702b96e4d8b130c91a040/68747470733a2f2f73756269637572612e636f6d2f6173736574732f61727469636c655f696d616765732f323031372d30312d31392d646f636b65722d67756964652d666f722d626567696e6e6572732d312f696d6167652d6c617965722e706e67)
- 도커 이미지는 컨테이너를 실행하기 위한 모든 정보를 가지고 있기 때문에 보통 용량이 수백MB ~ 몇GB이다.
- 다운받은 기존 이미지에 파일이 하나 추가되어서 전체를 다시 다운받는 것은 비효율적이다.
- 이러한 문제를 해결하기 위해 도커는 *레이어* 라는 개념을 도입하여 변경된 부분만 다운받을 수 있게 되었고, 
유니온 파일 시스템을 이용하여 여러 개의 레이어를 하나의 파일 시스템으로 사용할 수 있게 되었다.
- 그림 예시
  - ubuntu 이미지가 A + B + C의 집합
  - ubuntu 이미지를 베이스로 만든 nginx 이미지는 A + B + C + nginx
  - webapp 이미지를 nginx 이미지 기반으로 만들었다면 A + B + C + nginx + source
  - webapp 소스를 수정하면 A, B, C, nginx 레이어를 제외한 새로운 source(v2) 레이어만 다운
- 컨테이너를 생성할 때도 레이어 방식을 사용하는데 ```docuer run [이미지]```를 사용할 경우 기존의 image 
레이어(Read only layer) 위에 container 레이어를 추가한다.
```💡 
컨테이너 안의 모든 작업들은 Container 레이어에 기록된다.(Readable/Writable layer)
컨테이너 레이어는 해당 컨테이너가 종료될 경우 같이 소멸된다. 
```

### 컨테이너
- 이미지의 실행 가능한 인스턴스이며, 도커 API 또는 CLI를 사용하여 컨테이너를 관리
- 기본적으로 컨테이너는 다른 컨테이너 호스트 시스템과 격리되어 있다.
- 컨테이너는 논리적으로 분리되어 있기 때문에 호스트 시스템에서 컨테이너 시스템으로 접근하기 위해선 추가
설정이 필요하다.
- 컨테이너를 제거하면 DockerVolume을 통해 호스트 OS예 영구저장 하지 않는 이상 변경사항은 사라진다.

## 도커를 사용할 때의 흐름
![Untitled](https://camo.githubusercontent.com/c4ab0c8ff0a5520e3c555d5bc7eead4da80d836f3bc7234534e03ed78b6c2855/68747470733a2f2f646f63732e646f636b65722e636f6d2f656e67696e652f696d616765732f6172636869746563747572652e737667)
- docker run {이미지}를 사용했을때의 흐름은 다음과 같습니다.(cache 빠져있음 주의)
  1. 커맨드에 입력한 명령어를 도커 클라이언트에 전달한다.
  2. 도커 클라이언트가 도커 서버로 REST API 요청을 보낸다.
  3. 도커 서버에서 이미지가 로컬에 cache되어 있는지 확인한다.
    3-1. cache 되어 있으면 해당 이미지를 사용한다.
    3-2. 존재하지 않으면 docker hub에서 이미지를 가져온 다음 로컬 cache에 저장한다.
  4. 이미지를 통해 컨테이너를 생성한다.
  5. Image 레이어를 생성하고 그 위에 Container 레이어를 배치한다.
  6. Bridge/Network Interface를 이용해 Docker와 Host OS간의 통신을 열어준다.
  7. 사용가능한 IP 주소를 연결해준다.
  8. 애플리케이션을 실행한다.


## Docker 장단점
- 위에서 언급한 도커의 장점을 정리
### 장점
- 표준화된 사용자 환경에서 작업하여 개발 수명 주기를 간소화 할 수 있다.
- 응답성 있는 배포 및 확장으로 PC, 로컬서버, 클라우드 서버에 상관없이 일관성 있게 여러 환경에서 실행할 수
있기 때문에 시스템의 확장과 축소에 용이하다.
- 가볍고 빠르기 때문에 하이퍼바이저 시스템 보다 실용적이고 적은 비용이 든다.
```
💡 반드시 하이퍼바이저보다 도커가 우수한건 아니다. 구성환경에 따라 배포 환경이 다르기 때문에 충분히 검토하고
토입하여야 한다.
```

### 단점
- CLI 환경만 제공하기 때문에 Linux 명령어에 익숙해야 한다
- 리눅스 환경에서만 동작한다. 하지만 최근 Window의 WSL2를 통해 Windows 환경에서도 Linux를 간편하게
사용할 수 있어 단점이 해결되었다.

## 부록 A 오케스트레이션과 쿠버네티스

### 서버 오케스트레이션
- 여러 서버와 서비스를 자동으로 관리해주는 작업
- 각 작업에는 스케줄링, 클러스터링, 서비스 디스커버리, 로깅, 모니터링과 같은 기능이 포함된다.
- 대표적인 4가지 기능 설명
- 스케줄링
  - 컨테이너를 적당한 서버에 배포해주는 역할을 담당한다.
  - 컨테이너의 수를 여러 개로 나눠서 배포하고, 컨테이너가 죽으면 즉시 컨테이너를 다른 서버에 배포할 수 있다.
- 클러스터링
  - 여러 개의 서버를 하나의 서버처럼 사용할 수 있다.
  - 클러스터에 새로운 서버를 추가하거나 제거할 수 있고, 네트워크를 통해 멀리 떨어져 있는 서버를 사용할 수 있다.
- 서비스 디스커버리
  - 서비스를 찾아주는 기능이다. 해당 기능을 사용하기 위해ㅓ
- 로깅, 모니터링
  - 여러 대의 서버를 관리하는 경우 로그와 서버 상태를 한곳에서 관리
  - ELK나 Prometheus와 같은 툴을 사용해도 된다.
- 설치와 관리가 어렵고 도입 시 많은 비용과 관리비가 추가적으로 들어간다. 또한, 러닝커브도 크며 장애가 생기면
전체 서버에 영향이 가는 등 여러가지 단점이 존재한다.
- 이러한 문제를 해결하기 위해 Docker Swarm, Kubernetes와 같은 컨테이너 오케스트레이션이 등장하여 구축비용을
줄이고 다양한 기능을 쉽게 사용할 수 있게 되었다.


### 쿠버네티스
![Untitled](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FzfKCv%2Fbtq81ZSYa47%2F3SCUcf3hv3hqqai5t6wUKK%2Fimg.png)
- 컨테이너 기반의 오케스트레이션 플랫폼으로 다수의 컨테이너를 효율적으로 관리할 수 있다.
- 구글은 도커가 탄생하기 이전부터 컨테이너 기술을 상용 환경에서 사용하고 있었고, 내부적으로 컨테이너 관리
시스템을 개발하여 사용중에 있었다. 기존 기술이 발전되어 오픈소스화 된게 쿠버네티스이다.
- 생성과 소멸, 시작 및 중단 시점 제어, 스케줄링, 로드 밸런싱, 클러스터링 등 컨테이너로 어플리케이션을
구성하는 모든 과정을 관리할 수 있다.