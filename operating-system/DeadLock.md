## DeadLock 개념
![Untitled](https://miro.medium.com/max/700/1*h6f0e6M1MHCCzSdEspjIPA.png)
- 두개 이상의 프로세스가 서로의 작업이 끝나기만을 기다리고 있어 둘다 영원히 끝나지 않는 상황을 가리킨다
- 다중 쓰레드 프로그래밍 환경에서 흔히 발생하는 문제다.
- 위 그림 설명
  - Thread2는 A를 점유하고 있으면서 B의 자원을 요청, B의 자원을 습득할 때 까지 대기
  - Thread3는 B를 점유하고 있으면서 A의 자원을 요청, A의 자원을 습득할 때 까지 대기
  - 서로가 상대방이 자원을 내놓기를 바라면서 무기한 연기 상황에 빠지는 상황
- 시스템 파일이나 다른 프로그램이 공유하는 파일을 건드리기 쉬운 프로그램 설치 과정에서 종종, 
"프로그램을 설치할 때는 가능하면 다른 프로그램은 꺼주세요"라는 문장이 나오면서 모든 프로그램이 꺼지는 경우가
있는데, 이런 경우가 데드락이 발생할 수 있는 가능성 때문이다.
- 또다른 정의로는, 스레드 혹은 프로세스가 세마포어를 차지하려는 경쟁에서 발생한다.
※ 세마포어 : 일정 시간 동안 여러 프로세스에서 사용하지만 한 순간에서는 한 프로세스에서만 사용하는 자원
![Untitled](https://media.vlpt.us/images/chappi/post/1c66c856-bfe4-4772-96f7-37ef017245b4/2.png)
- 교착 상태는 공유 변수를 사용할 때도 발생한다
- 프로세스 P1이 lock1을 true로 만들고, P2가 lock2를 true로 만든다면, P1으로 돌아왔을 떄 while문이 실행되어 무한 반복된다. 
P2도 while이 실행되어 무한히 반복된다.
- P1과 P2 둘 다 임계구역에 들어가지 못하는 교착 상태가 발생하는 것이다. 이처럼 한 변수를 할당 받은 상태에서 
다른 변수를 기다리면 교착 상태가 발생한다.
※ 임계 구역이란 둘 이상의 스레드가 동시에 접근해서는 안되는 공유 자원을 접근하는 코드의 일부를 말한다.
  한 스레드가 자신의 임계구역에서 수행하는 동안에는 다른 스레드는 해당 임계구역에 들어갈 수 없는데 위에서는 
  다른 스레드도 들어가서 값을 변경시켜 DeadLock이 발생한 경우다.

## 시스템 모델 설명
- 데드락을 자세히 이해하기 전에 컴퓨터 시스템에서 자원을 획득하는 과정을 알아야 한다.
1. 자원을 사용하게 위해 프로세스가 특정 자원을 시스템에게 **요청**한다.
2. 시스템은 요청받은 자원이 사용가능한지 그렇지 않은지 판단 후, 사용 가능하면 프로세스에게 할당한다. 
3. 만일 자원이 다른 프로세스에 의해 이미 점유 되어 있는 경우 요청 프로세스는 **자원이 사용 가능해 질 때까지 기다린다(Wait state)**
4. 자원에 대한 허가가 떨어지면 프로세스는 자원을 **사용**할 수 있다.
5. 프로세스는 자원 사용이 끝나면, 시스템에게 반환 요청(**해제**)을 한다.
6. 시스템은 자원을 반환 받아 다른 필요한 프로세스가 있다면 해당 프로세스에게 할당해준다.
- 자원에 대한 권한을 획득하고 돌려주기 위해 open과 close 시스템 콜을 호출, 메모리(자원)를 확보하고 해제하기 위해
allocate와 free를 호출하는 것과 같은 모든 행동들이 위와 같은 과정(요청 -> 사용 -> 해제)과정에 속하는 것들이다.
- 데드락은 특정 셋(set)에 속한 모든 프로세스가 대기 상태(Wait state)상태에서 빠져 나오지 못하는 상태를 말한다.

## DeadLock 발생 조건
![Untitled](https://user-images.githubusercontent.com/52563841/152352811-e57abf45-5ebc-49e7-9554-359687e18a2f.png)
- 데드락이 발생하기 위해서는 아래의 4가지 조건이 동시에 만족을 해야 한다.
- 4가지 조건에 다 맞았다고 해서 반드시 교착상태가 일어나는 건 아니고 통상 교착상태가 일어난 상황을 보면
아래 4가지 조건에 만족했다는 것이다.

### 상호 배제 (Mutual Exclusion)
- 매 순간 하나의 프로세스만이 자원을 사용할 수 있다.
- 적어도 하나의 자원을 나 혼자만 점유해서 사용한다.
- 프린터 등의 일부 입출력 장치나 연산 결과를 저장하는 변수와 같이 동시에 건드리면 위험한 자원들이 있어
해당 속성을 없에는 것은 불가능 하다.

### 점유와 대기 (Hold and wait)
- 최소한 하나의 자원을 소유하고 있는 상태에서 다른 프로세스가 소유하고 있는 추가 자원을 요청
- 식사하는 철학자 문제
- ![Untitled](https://ww.namu.la/s/24ad59b9924a16433407eae0c36a52de73c04a5a0f9014414a473ce5b0390efdb545e8e89270c6d36426654001d1672c78b34590281f978235da7df6ea03e0b3c6ff1bc59961f2942f7c76d33569f9509cd2e2db7cd053a39c891f91752b45622cb1b8ccd63f9f5ef646efed74025e1d)
- 포크를 양손에 잡아야 식사할 수 있다고 가정
- 모든 철학자들이 동시에 자신의 왼쪽 포크를 잡은 상태에서 자기의 오른쪽의 포크를 집으려고 봤더니 다른 철학자가
사용하고 있어서, 오른쪽 포크가 사용 가능해질 때까지 기다려야 한다.

### 비선점 (No preemption)
- 자원들은 그들이 점유하고 있는 프로세스로부터 도중에 해제되지 않는다.
- 그 어떤 프로세스도 다른 프로세스가 소유하고 있는 자원을 강제로 뺏아 올 수 없다
- 위의 철학자 문제에서 보자면, 왼쪽 포크(공유 자원)를 가졌는데 진행이 안되므로 내려 놓으면 preemption, 
내려놓지 않은 상태를 no preemption이라 할 수 있다.
- 만약 우선순위 선점이 가능해진다면, 프린터가 출력하는 도중 자원을 뺏거나, Skype에서 녹음기가 마이크를 뺏어와서 먼저 자기 할일을 할 수 있다.

### 순환 대기(Circular wait)
  ![Untitled](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FLb4LW%2Fbtq5vEkbRE0%2FRZJ1gFZNcHT9Xk6rHRAE71%2Fimg.png)
  - 프로세스와 자원들이 원형을 이루며, 각 프로세스는 자신에게 할당된 자원을 가지면서, 상대방 프로세스의 자원을 상호 요청 하는 경우
  - 위 그림상 
    - P1은 P2이 가진 자원을 기다림
    - P2는 P3가 가진 자원을 기다림
    - P3은 P4이 가진 자원을 기다림
    - P4는 P1이 가진 자원을 기다림

## DeadLock 탐지 방법
### 자원 할당 그래프
![Untitled](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdWO5az%2Fbtq5vD6FQRF%2F3k33gg5PnBZjDsZcnTcPAK%2Fimg.png)
- 프로세스가 자원을 요청하고 자원이 프로스세에게 할당되는 **방향성을 가진 그래프**로써, 데드락 발생 여부를
탐지할 수 있는 그래프다. 
- 동그라미 P1, P2, P3 : 프로세스
- 사각형 R1, R2, R3, R4 : 자원타입, 점들은 할당 가능한 자원 인스턴스 개수
※ 해당 자원들은 여러 프로세스에 의해 공유 될수 없는 자원이라 가정
- 파랑색 선 : 프로세스가 자원을 요청만하고 할당 받지 못한 상태(대기 상태)
- 빨강색 선 : 자원이 프로세스에게 할당 되었음을 의미
- 위 그래프는 아래와 같다.
  - P1은 R2의 자원을 점유하고 R1의 자원을 대기 중이다 - 점유 대기(Hold and wait)
  - P2는 R1과 R2의 자원을 점유하고 R3의 자원을 대기 중이다 - 점유 대기(Hold and wait)
  - P3은 R3의 자원을 가지고 있지만 아무런 추가 자원을 요청하지 않는다.
- P3가 아무런 자원을 요청하지 않고 있으므로 순환대기 상태가 아니다. 즉, 데드락 상태가 아니다

![Untitled](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FI1RvP%2Fbtq5xu2Qigr%2FIk09zstjlr6jcialT145C0%2Fimg.png)
- 위 그래프는 P3이 R2의 자원을 요청한 상황이다
- R2는 이미 할당 할 수 있는 자원을 모두 사용 했으므로, P3은 대기상태에 빠진다
- R2는 P2에게 할당 되었고, P2는 R3을 기다리고 있다. 하지만 R3은 이미 P3에게 할당 되어 있어 순환 대기 상태에 빠지게 되었다.
- 데드락 발생!!!

![Untitled](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FlcXTJ%2Fbtq5wvOLkj3%2F7DOrbkQgDZ4sVvxLCeXSDk%2Fimg.png)
- 순환대기 상태처럼 보여 데드락처럼 보이지만 데드락이 아니다
- P3에서 작업이 완료되고 자원을 해제하면 P1에게 할당될 수 있다.
- 마찬가지로, P4에서 작업이 완료되고 자원을 해제하면 P2에게 할당될 수 있으므로 순환 대기 상태가 아니다

## DeadLock 처리 방법

### 예방
- DeadLock의 네 가지 조건 중 한가지만이라도 발생하지 못하도록 막는다.
- 상호 배제 방지
  - 자원을 공유하도록 만든다. Read-Only 파일이 좋은 예시
  - 파일이 변경되지 않는다면 동시에 파일에 접근 가능하고, 자원을 점유하기 위해 대기하는 프로세스가 없다.
  - 자원을 공유하게 됨으로서 임계구역이 보호받지 못하는 문제가 발생한다.
  - 또한, 프린터와 같은 근본적으로 공유가 불가능한 프로세스가 존재하기 때문에 DeadLock을 예방할 수 없다.
- 점유와 대기 방지
  - 프로세스가 자원을 요청할 때 다른 어떤 자원도 가지고 있지 않도록 해야 한다.
  - 프로세스를 시작할 때 모든 필요한 자원을 할당받게 하거나, 자원이 필요한 경우 보유하고 있던 자원을 모두 
  반납하고 다시 요청하는 방식을 이용한다.
  - 비선점과 예방은 자원에 대한 제약을 풀어버리는 방식이지만, 해당 방식은 자원이 아닌 프로세스의 자원 
  사용 방식을 변화시킨다.
  - 아래와 같은 단점이 존재한다.
    - 프로세스가 자신이 사용하는 모든 자원을 자세히 알기 어렵다.
    - 자원의 활용성이 떨어진다.
    - 많은 자원을 사용하는 프로세스가 적은 자원을 사용하는 프로세스보다 자원 선점에 불리하다.(기아 현상)
    ※ 기아 상태 : 특정 프로세스가 우선순위가 낮아서 원하는 자원을 계속 할당 받지 못하는 상태
    - 일괄 작업 방식으로 동작해야 한다.
      - 자원을 확보한 프로세스가 자원을 잠깐 사용하든, 오래 사용하든 상관없이 무조건 확보한 후 실행해야 하므로
      다른 프로세스는 해당 자원을 기다려야 하는 단점이 존재한다.
- 비선점 방지
  - 자신이 점유하고 있는 자원을 강제로 반납 해 다른 프로세스가 선점하게 만든다.
  - 만일 어떤 자원을 점유하고 있는 프로세스B가 즉시 할당할 수 없는 다른 자원을 요청하면 현재 프로세스A가 
점유하고 있는 모든 자원이 방출되어 필요로 하는 프로세스B에게 선점된다.
  - 프로세스A는 자신이 요청하고 있는 새로운 자원은 물론 현재 강제로 방출한 옛 자원들을 다시 획득할 수 
있을 때에만 다시 시작된다.
    - 자신이 가지고 있던 상태를 잃어버리고 처음부터 진행해야 하기 때문에 사용한다면 상태를 쉽게 저장하고 
복구할 수 있는 CPU나 memory에 주로 사용할 수 있다.
  - 자원을 빼앗을떄 어떤 기준으로 빼앗을지, 뺴앗은 자원 중 얼마나 사용해야 할지를 결정하는 것이 어렵다.
  - 이러한 방식은 기아현상이 발생할 수 있다.
    - 우선 순위가 높은 프로세스가 자원을 무조껀 선점해버리면 우선순위가 낮은 프로세스는 기아 현상에 빠지게 된다.
- 순환 대기 방지
  - ![Untitled](https://media.vlpt.us/images/chappi/post/d5db6dc7-435a-4392-a7ab-975f64debecc/1.png)
  - 점유와 대기를 하는 프로세스들이 원형을 이루지 못하도록 막는 방법이다.
  - 자원을 한 병향으로만 사용하도록 설정함으로써 원형 대기를 예방한다.
  - 모든 자원마다 고유의 번호를 부여하고 필요한 자원을 번호가 작은 것 부터 큰 순서대로 획득하도록 한다면
추가로 필요한 자원들이 어떠한 프로세스에게도 점유 되어 있지 않음을 보장한다.
  - 점유와 대기와 같이 프로세스 작업 방식에 대한 해결이다.
  - 위 그림에서 자원 선점을 오른쪽으로 다가갈 순 있지만 왼쪽으로는 못가게 함으로서 일렬로 만든다.
  - ![Untitled](https://media.vlpt.us/images/chappi/post/f464ff42-92e8-43b5-bc82-1c444c7bffee/2.png)
  - P1은 R1을 할당받은 상태에서 자원 R2를 기다리고 있다.
  - P2는 R2를 할당받은 상태에서 R1을 기다린다. 그런데 R1의 번호가 작아서 P2의 요청이 거절된다.
  - P2는 R1을 할당받을 수 없어서 강제 종료되고 P1은 R2를 할당받아 정상적으로 실행된다.
  - 작은 번호의 자원을 사용할 수 없게 하면 원형이 생기지 않는다.
  - 아래와 같은 단점이 있다.
    - 프로세스 작업 진행에 유연성이 떨어진다
      - 자원을 할당받지 못한 프로세스는 P2와 같이 종료될텐데 만약 중요한 프로세스 였다면 사용성이 떨어진다.
    - 자원의 번호를 어떻게 부여할 것인가?
      - 프로세스가 큰 번호의 자원을 사용한 후 작은 번호의 자원을 사용할 수 없기 때문에 자원에 번호를 붙이는 데 
      매우 신중해야 한다.
      
### 회피
- 데드락 회피 알고리즘은 프로세스가 작업을 완료하는데 필요한 최대 자원의 개수를 OS에게 제공한뒤에,
OS가 자원 할당 상태를 검사하여 DeadLock이 발생할 것 같은 요청을 거절한다.
![Untitled](https://media.vlpt.us/images/chappi/post/09789185-1326-47cb-8f13-42214c97ae31/3.png)
- 자원의 총수와 현재 할당된 자원싀 루르 기준으로 OS를 안전상태와 불안전상태로 나눈다.
  - 안전 상태 : OS가 각 프로세스들에게 DeadLock을 피할 수 있는 **안전한 순서열**로 자원을 배분할 수 있는 상태
  - 불안전 상태 : 안전한 순서열이 존재하지 않는 상태로, 교착상태의 발생 가능성이 있다.
- 위 그림에서 할당된 자원이 적으면 안정 상태가 크고, 할당된 자원이 늘어날수록 불안정 상태가 커진다.
- 불안정 상태에서 항상 데드락이 발생하는 것은 아니다. 데드락은 불안정 상태의 일부분이며, 불안정 상태가 커질수록 
교착 상태가 발생할 가능성이 높아질 뿐이다.
- 프로세스들이 자원을 요청 할때 마다 안전 상태를 유지할 수 있을 경우에만 자원을 할당한다.
- 위와 같은 검사를 하기 위한 알고리즘들이 존재한다.
※ DeadLock 방지와 회피의 차이
- 방지는 read-only, OS의 선점, 자원을 몰아서 가져가거나 순서대로 자원을 접근 하는 등 프로세스 입장에서 경쟁해야 한다.
- 회피의 경우는 특정 알고리즘을 이용하여 애초에 시스템에서 데드락이 발생하지 않도록 자원을 배분해준다.

#### 자원 할당 그래프 알고리즘
![Untitled](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FNk8VX%2Fbtq5yB18VVH%2FSgz7t7x5B7rspBTEkfLFv0%2Fimg.png)
- 자원 타입 당 사용할 수 있는 인스턴스가 하나일 경우 사용할 수 있는 알고리즘이다.
- 기존의 자원 할당 그래프에서 클레임 화살표가 추가되었다.
  - 클레임 화살표는 프로세스가 미래 언젠가 자원을 요청할 수도 있다는 것을 나타낸다
  - DeadLock 회피에서 언급한 필요한 최대 자원의 개수가 해당 알고리즘에서는 클레임 화살표와 동일하다(추가 정보)
- 운영체제는 위와 같은 그래프를 유지하며, 프로세스로부터 자원에 대한 요청을 받으면 순환 대기 상태가 발생하지 않는
경우에만 자원을 할당한다.
- 순환 대기 상태를 탐지하기 위해서 써클 탐지(circle-detection) 알고리즘을 사용한다.
- 위 그래프 과정 예시
  1. P2가 자원 R2를 요청한다.
  2. OS는 R2가 어떠한 프로스세엑 할당 되지 않은 상태라고 할지라도 P1의 클레임 화살표가 있기 때문에 바로
  할당해주지 않고 대기한다.
  3. 언제든지 P1이 R@의 자원을 요청할 수 있다. 만일, P2가 R2를 할당받은 시점에서 P1이 R2의 자원을 요청한다면
  순환대기 상태가 발생한다.
  4. 이러한 상황을 막기위해 OS는 애초에 P2의 요청을 거절해 버림으로써 데드락을 회피한다.
- 단점으로는 자원 할당 그래프를 유지하고, 갱신하고, 사이클을 검사하는 추가 작업으로 인해 오버헤드가 발생할 수 있다.

#### 은행원 알고리즘
- 자원 타입 당 사용할 수 있는 인스턴스가 여러개일 경우 사용할 수 있는 알고리즘이다.
- 위에서 살펴본 안전 상태와 불안전 상태의 개념을 이용하여 시스템이 프로세스에게 자원을 할당했을 때 안전 상태가 
유지되는 경우만 자원을 할당하고 그렇지 않은 경우 프로세스는 자원 요청을 하지 않고 대기 하게 된다.
- 은행에서 대출 금액이 대출 가능한 범위 내이면(안정 상태이면) 허용되지만 그렇지 않으면 거부되는 것과 유사하기 때문에
이름이 은행원 알고리즘이라 불리게 되었다.
- 은행원 알고리즘의 핵심은 가능한 자원 내에서 필요한 수를 가장 빠르게 맞출 수 있는 것을 먼저 처리하는 것이 핵심이다.
- 은행원 알고리즘은 다음과 같은 자료구조가 있다.
  | 변수   | 설명                                         |
  | -------------- | ---------------------------------------------- |
  | 전체자원(Total)       | 시스템 내 전체 자원의 수 |
  | 가용자원(Available)   | 시스템 내 현재 사용할 수 있는 자원의 수(전체 자원 - 모든 프로세스의 할당 자원) |
  | 최대 자원(Max)        | 각 프로세스가 선언한 최대 자원의 수 |
  | 할당 자원(Allocation) | 각 프로세스에 현재 할당된 자원의 수 |
  | 기대 자원(Expect)     | 각 프로세스가 앞으로 사용할 자원의 수(최대 자원 - 할당 자원) |
- 안전상태 예시
  ![Untitled](https://media.vlpt.us/images/chappi/post/46a78468-a525-4a89-a337-b8d27cb458b9/4.png)
  - 가용 상태가 2개 인데 프로세스 P2가 필요로 하는 자원이 2개이므로 안전상태이다.
  - P2가 가용 자원 2개를 사용하여 실행을 종료하면 이미 할당받아 사용하던 자원 6개를 반환한다.
  - 가용 자원이 6개가 되며, 해당 자원을 이용해 P1과 P2 작업을 마무리 할 수 있다.
  - 만약 가용자원을 P1이나 P3에 할당하면 기대 자원을 충족할 수 없기 때문에 작업을 마칠 수 없다(안전 순서열)
- 불안전상태 예시
  ![Untitled](https://media.vlpt.us/images/chappi/post/19b92fe4-8870-456b-8670-1faf6bf92f66/5.png)
  - 가용 자원이 1개인데 해당 자원으로 어떤 프로세스의 기대 자원도 충족할 수 없다.

- 은행원 알고리즘은 아래와 같은 단점이 있다.
  - 할당할 수 있는 자원의 수가 일정해야 한다
  - 사용자 수가 일정해야 한다
  - 항상 불안전 상태를 방지해야 하기 때문에 자원 이용도가 낮다
  - 최대 자원 요구량(Max)를 미리 알아야 한다
  - 프로세스들은 유한한 시간 안에 자원을 반납해야 한다
- 이러한 단점들 때문에 은행원 알고리즘은 굉장히 복잡하며 실제 상황에 접목시키기 어려우며, 
따라서 현재 사용하는 방식은 아니다

### 탐지
- 예방은 구현하기 어렵고 회피는 구현할 수 있지만 리소스 낭비라는 문제가 있다.
- 가장 현실적인 방안은 탐지이다.
- OS가 프로세스의 작업을 관찰하면서 DeadLock 발생여부를 계속 주시하는 방식이다.
- 만약 DeadLock을 발견하면 이를 해결하기 위해 회복 단계를 밟는다
- 탐지 알고리즘은 2가지가 있다.

#### 대기 그래프 (Wait-for Graph)
![Untitled](https://media.vlpt.us/images/lcy960729/post/6d5c56d2-8dda-49c0-954c-e1c78745797a/image.png)
- 각 자원 유형의 단위 자원이 하나만 있는 경우에 사용한다.
- 자원 할당 그래프의 변형으로, 자원 할당 그래프에서 자원 노드를 제거하고 프로세스 간의 간선으로 나타낸 그래프이다.
  - (a)는 자원할당 그래프이며 (b)는 (a)를 대기 그래프로 만든것
- Ti -> Tj의 의미는 Ti는 Tj가 가지고 있는 자원들 중 Ti가 필요한 자원이 반납 되기까지 대기중이라는 의미이다.
- Ti -> Tj는 Ti->R와 R->Tj를 포함하는 경우만 대기 그래프가 존재한다.
- 대기 그래프에서 사이클이 포함되는 경우만 교착 상태가 존재한다.
- 교착 상태 탐지를 위해 운영체제는 대기 그래프를 유지하여야 하며, 주기적으로 사이클을 탐지하는 알고리즘을 호출

#### Shoshani & Coffman 알고리즘
- 각 자원 유형의 단위 자원이 여러 개일 경우 사용한다.
- 은행원 알고리즘 처럼 상태 정보를 가지는 자료 구조를 사용한다.
- 은행원 알고리즘에서의 예시와 같다.

#### 탐지 알고리즘의 사용
- 아래와 같은 기준을 잡아서 탐지 알고리즘을 돌릴지 말지 정해야 한다.
  1. DeadLock이 얼마나 자주 일어나는가?
  2. DeadLock이 일어나면 대략 몇개의 스레드가 포함되는가?
- 자원 요청에 대해 대기를 해야할 때 탐지 알고리즘을 돌리는 방법도 있다.
  - 자원을 요청할 때마다 탐지 알고리즘을 호출하는 것이기 때문에 많은 오버헤드가 발생한다.
- 아니면 지정된 시간 간격으로 돌리거나 CPU 이용률을 기준으로 돌린다.
  - 해당 방법으로 호출하면 DeadLock을 야기한 스레드는 알 수 없다.

### 회복
- DeadLock이 탐지되면 DeadLock을 푸는 작업을 한다.
- 교착 상태를 유발한 프로세스를 강제로 종료시켜 자원을 회수한다.
- 프로세스를 강제 종료하는 방법 2가지
  - 교착 상태를 일으킨 모든 프로세스를 동시에 종료
    - 이 방법은 종료된 프로세스들이 동시에 작업을 시작하면 다시 DeadLock을 일으킬 가능성이 크다.
  - 교착 상태를 일으킨 프로세스 중 하나를 골라 순서대로 종료
    - 프로세스를 종료할 때 아래와 같은 기준으로 순서를 지정해야 한다.
    1. 우선순위가 낮은 프로세스를 먼저 종료한다.
    2. 우선순위가 같은 경우 작업 시간이 짧은 프로세르를 먼저 종료한다.
    3. 위의 두 조건이 같은 경우 자원을 많이 사용하는 프로세스를 먼저 종료한다.
- DeadLock이 발생하기 전 상태로 롤백해 강제 종료한 프로세스를 재시작한다.
- 롤백은 명령어가 실행될 때마다 체크포인트를 만들어 최근의 검사 시점으로 돌아간다.
- 그러나, 이 방법은 작업량이 상당하여 시스템에 부하를 주므로 체크포인트를 무분별하게 사용하는 것은 좋지 않다.
- 탐지와 같이 사용되며 탐지&회복으로 불리기도 한다.

### 무시
- DeadLock이 일어나지 않는다고 생각하고 아무런 조치도 취하지 않는 방법
- DeadLock이 매우 드물게 발생하기 때문에 위의 기법들을 사용하는거이 오히려 큰 오버헤드일 수 있기 때문이다.
- 만약 DeadLock이 발생하여 시스템이 비정상적으로 작동하는 것을 사람이 느끼면 직접 프로세스를 죽이는 방법으로 대체한다.
- 해당 방식은 UNIX, Windows 등 대부분의 범용 OS에서 채택하는 방식이다.